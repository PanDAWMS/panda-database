-- Generated by Ora2Pg, the Oracle database Schema converter, version 21.1
-- Copyright 2000-2020 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:PDBR

SET client_encoding TO 'UTF8';

SET search_path = doma_pandabigmon,public;
\set ON_ERROR_STOP ON

SET check_function_bodies = false;

DROP TRIGGER IF EXISTS all_requests_daily_trg ON all_requests_daily CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_all_requests_daily_trg() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('all_requests_daily_id_seq')
  INTO STRICT NEW.ID
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_all_requests_daily_trg() OWNER TO panda;

CREATE TRIGGER all_requests_daily_trg
	BEFORE INSERT ON all_requests_daily FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_all_requests_daily_trg();

DROP TRIGGER IF EXISTS all_requests_trg ON all_requests CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_all_requests_trg() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('all_requests_id_seq')
  INTO STRICT NEW.ID
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_all_requests_trg() OWNER TO panda;

CREATE TRIGGER all_requests_trg
	BEFORE INSERT ON all_requests FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_all_requests_trg();

DROP TRIGGER IF EXISTS auth_group_tr ON auth_group CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_auth_group_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT nextval('auth_group_id_seq')
        INTO STRICT NEW.id;
RETURN NEW;
END;



/*
CREATE TABLE AUTH_GROUP_PERMISSIONS 
(
  ID NUMBER(11, 0) NOT NULL 
, GROUP_ID NUMBER(11, 0) NOT NULL 
, PERMISSION_ID NUMBER(11, 0) NOT NULL 
, CONSTRAINT SYS_C002462750 PRIMARY KEY 
  (
    ID 
  )
  ENABLE 
); 
*/
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_auth_group_tr() OWNER TO panda;

CREATE TRIGGER auth_group_tr
	BEFORE INSERT ON auth_group FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_auth_group_tr();

DROP TRIGGER IF EXISTS auth_user_tr ON auth_user CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_auth_user_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT nextval('auth_user_tr_seq')
        INTO STRICT NEW.id;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_auth_user_tr() OWNER TO panda;

CREATE TRIGGER auth_user_tr
	BEFORE INSERT ON auth_user FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_auth_user_tr();

DROP TRIGGER IF EXISTS auth_user_user_id_p_trg ON auth_user_user_permissions CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_auth_user_user_id_p_trg() RETURNS trigger AS $BODY$
BEGIN
        SELECT nextval('auth_user_user_id_p_seq')
        INTO STRICT NEW.id;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_auth_user_user_id_p_trg() OWNER TO panda;

CREATE TRIGGER auth_user_user_id_p_trg
	BEFORE INSERT ON auth_user_user_permissions FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_auth_user_user_id_p_trg();

DROP TRIGGER IF EXISTS django_migrations_tr ON django_migrations CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_django_migrations_tr() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('django_migrations_id_p_seq')
  INTO STRICT   NEW.ID
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_django_migrations_tr() OWNER TO panda;

CREATE TRIGGER django_migrations_tr
	BEFORE INSERT ON django_migrations FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_django_migrations_tr();

DROP TRIGGER IF EXISTS objects_comparison_trg ON objects_comparison CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_objects_comparison_trg() RETURNS trigger AS $BODY$
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF TG_OP = 'INSERT' AND coalesce(NEW.ID::text, '') = '' THEN
      SELECT nextval('objects_comparison_seq') INTO STRICT NEW.ID;
    END IF;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_objects_comparison_trg() OWNER TO panda;

CREATE TRIGGER objects_comparison_trg
	BEFORE INSERT ON objects_comparison FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_objects_comparison_trg();

DROP TRIGGER IF EXISTS request_stats_trigger ON request_stats CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_request_stats_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('request_stats_seq')
  INTO STRICT   NEW.id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_request_stats_trigger() OWNER TO panda;

CREATE TRIGGER request_stats_trigger
	BEFORE INSERT ON request_stats FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_request_stats_trigger();

DROP TRIGGER IF EXISTS rucio_accounts_trigger ON rucio_accounts CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_rucio_accounts_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('rucio_accounts_seq')
  INTO STRICT   NEW.id
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_rucio_accounts_trigger() OWNER TO panda;

CREATE TRIGGER rucio_accounts_trigger
	BEFORE INSERT ON rucio_accounts FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_rucio_accounts_trigger();

DROP TRIGGER IF EXISTS social_auth_association_tr ON social_auth_association CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_social_auth_association_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT nextval('social_auth_association_sq')
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_social_auth_association_tr() OWNER TO panda;

CREATE TRIGGER social_auth_association_tr
	BEFORE INSERT ON social_auth_association FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_social_auth_association_tr();

DROP TRIGGER IF EXISTS social_auth_code_tr ON social_auth_code CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_social_auth_code_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT nextval('social_auth_code_sq')
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_social_auth_code_tr() OWNER TO panda;

CREATE TRIGGER social_auth_code_tr
	BEFORE INSERT ON social_auth_code FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_social_auth_code_tr();

DROP TRIGGER IF EXISTS social_auth_nonce_tr ON social_auth_nonce CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_social_auth_nonce_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT nextval('social_auth_nonce_sq')
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_social_auth_nonce_tr() OWNER TO panda;

CREATE TRIGGER social_auth_nonce_tr
	BEFORE INSERT ON social_auth_nonce FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_social_auth_nonce_tr();

DROP TRIGGER IF EXISTS social_auth_partial_tr ON social_auth_partial CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_social_auth_partial_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT nextval('social_auth_partial_sq')
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_social_auth_partial_tr() OWNER TO panda;

CREATE TRIGGER social_auth_partial_tr
	BEFORE INSERT ON social_auth_partial FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_social_auth_partial_tr();

DROP TRIGGER IF EXISTS social_auth_usersociala1245 ON social_auth_usersocialauth CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_social_auth_usersociala1245() RETURNS trigger AS $BODY$
BEGIN
        SELECT nextval('social_auth_usersociala0419')
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_social_auth_usersociala1245() OWNER TO panda;

CREATE TRIGGER social_auth_usersociala1245
	BEFORE INSERT ON social_auth_usersocialauth FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_social_auth_usersociala1245();

DROP TRIGGER IF EXISTS user_settings_tr ON user_settings CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_user_settings_tr() RETURNS trigger AS $BODY$
BEGIN
        SELECT nextval('user_settings_sq')
        INTO STRICT NEW.id;
    RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_user_settings_tr() OWNER TO panda;

CREATE TRIGGER user_settings_tr
	BEFORE INSERT ON user_settings FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_user_settings_tr();

DROP TRIGGER IF EXISTS visits_trigger ON visits CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_visits_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('visits_seq')
  INTO STRICT   NEW.VISITID
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_visits_trigger() OWNER TO panda;

CREATE TRIGGER visits_trigger
	BEFORE INSERT ON visits FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_visits_trigger();

DROP TRIGGER IF EXISTS rating_trigger ON rating CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_rating_trigger() RETURNS trigger AS $BODY$
BEGIN
  SELECT nextval('rating_seq')
  INTO STRICT   NEW.RATINGID
;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql';

ALTER FUNCTION trigger_fct_rating_trigger() OWNER TO panda;

CREATE TRIGGER rating_trigger
	BEFORE INSERT ON rating FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_rating_trigger();

